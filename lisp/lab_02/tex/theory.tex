\chapter{Теоретические вопросы}

\section{Базис языка Lisp. Ядро языка.}

\textbf{Базис языка} --- минимальный набор инструментов и структур данных, который позволяет решать любые задачи.

\begin{lstlisting}
    Базис Lisp = атомы + структуры + 
                 базовые функции + базовые функционалы
\end{lstlisting}

\textbf{Функция} --- правило, по которому каждому значению одного или нескольких аргументов ставится в соответствие конкретное значение результата.

Примеры функций:
\begin{lstlisting}
    CAR         ; возвращает головную часть списка
    CDR         ; возвращает хвостовую часть списка
    CONS        ; включить новый элемент в начало списка
    ATOM        ; проверить, является ли аргумент атомом
    EQ          ; проверить тождественность двух символов
\end{lstlisting}

\textbf{Функционал (функция высшего порядка)} --- функция, аргументом или результатом которой является другая функция.

Примеры функционалов:
\begin{lstlisting}
    APPLY       ; применить функцию к списку аргументов
    FUNCALL     ; вызвать функцию с аргументами
\end{lstlisting} 

\textbf{Ядро} --- основные действия, которые наиболее часто используются. Такие функции системы обычно реализовываны в виде машинных подпрограмм.


\section{Классификация функций}

\begin{enumerate}
    \item \textbf{Чистые математические функции} --- имеют фиксированное количество аргументов, сначала вычисляются все аргументы, а потом к ним применяется функция.
    \item \textbf{Рекурсивные функции} --- основной способ повторения повторных вычислений.
    \item \textbf{Специальные функции (формы)} --- могут принимать произвольное количество элементов, элементы могут обрабатываться по разному.
    \item \textbf{Псевдофункции} --- создают "эффект", например, вывод на экран.
    \item \textbf{Функции с вариантами значений}, из которых выбирается одно.
    \item \textbf{Функции высших порядков (функционалы)} --- функции, аргументом или результатом которых является другая функция.
\end{enumerate}

\section{Классификация базисных функций и функций ядра}
\begin{enumerate}
    \item Селекторы 
    \begin{lstlisting}
    CAR         ; возвращает первый элемент списка
    CDR         ; возвращает хвостовую часть списка
    \end{lstlisting}

    \item Конструкторы
    \begin{lstlisting}
    CONS        ; включить новый элемент в начало списка
    LIST        ; составить список из своих аргументов
    \end{lstlisting}

    \item Предикаты --- логические функции, позволяющие определить структуру элемента.
    \begin{lstlisting}
    ATOM        ; проверить, является ли аргумент атомом
    NULL        ; проверить, является ли аргумент пустым списком
    LISTP       ; проверить, является ли аргумент списком
    CONSP       ; проверить, является ли аргумент структурой,   
                  представленной в виде списковой ячейки
    \end{lstlisting}

    \item Функции сравнения (перечислены по мере роста "тщательности" проверки)
    \begin{lstlisting}
    EQ          ; сравнивает два символьных атома (= указатели)
    EQL         ; сравнивает атомы и числа одинакового типа
    =           ; сравнивает только числа, могут быть разных типов
    EQUAL       ; EQL + сравнивает списки 
    EQUALP      ; сравнивает любые S-выражения
    \end{lstlisting}
    
\end{enumerate}

\section{Способы задания функций}

Определение функций пользователя в Лиспе возможно двумя способами.

\subsection{Базисный способ определения функции}

Предполагает использование $\lambda$-выражения ($\lambda$-нотации). Так создаются функции без имени. 

Способ задания функции: \textbf{$\lambda$-выражение: (lambda $\lambda$-список форма)}, где $\lambda$-список --- формальные параметры функции, форма --- тело функции. 

Вызов такой функции осуществляется следующим образом: \textbf{($\lambda$-выражение формы)}, где формы --- это фактические параметры. 

Вычисление функций без имени может быть также выполнено с помощью функционала \textbf{apply}: \textbf{(apply $\lambda$-выражение формы)}. 
Функционал apply является обычной функцией с двумя вычисляемыми аргументами, обращение к ней имеет вид 
\begin{lstlisting}
    apply F L           ;   F -- функциональный аргумент 
                        ;   L -- список фактических параметров
\end{lstlisting}

Значение функционала --- результат применения F к этим фактическим параметрам.

Вычисление функций без имени может быть также выполнено с помощью функционала \textbf{funcall}: \textbf{(funcall $\lambda$-выражение формы)}. Функционал funcall --- особая функция с вычисляемыми аргументами, обращение к ней
\begin{lstlisting}
    funcall  F e1 .. en         ; n >= 0
\end{lstlisting}

Действие аналогично apply, отличие в том, что аргументы передаются не в виде списка, а по отдельности.

\subsection{Использование макро-определения defun}

Задание функции: \textbf{(defun имя-функции $\lambda$-выражение)} или в облегченной форме \textbf{(defun имя-функции ($x_1$, $x_2$, .. $x_k$) форма)}.

Вызов именованной функции: \textbf{(имя-функции последовательность-форм)}. 

Для вызова можно также воспользоваться функционалами funcall и apply.

\begin{lstlisting}
    (foo 1 2 3)
    (funcall  #'foo 1 2 3)
    (apply #'foo (1 2 3))
\end{lstlisting}

\section{Назначения и отличия в работе CONS и LIST}

CONS принимает два указателя на любые S-выражения и возвращает новую списковую ячейку, содержащую два значения. Если второе значение не NIL и не другая списковая ячейка, то получается точечная пара. По сути функция включает значение первого аргумента в начало списка, являющегося значением второго аргумента.

LIST составляет список из значений своих аргументов. Она создаст столько списковых ячеек, сколько ей было передано.  Относится к особым функциям, так как у нее может быть произвольное число параметров. 

Отличия:
\begin{itemize}
    \item CONS является базисной, LIST --- нет;
    \item CONS имеет фиксированное количество аргментов, LIST --- произволное;
    \item CONS создает точечную пару или список, LIST --- список;
    \item результат функции LIST симметричен относительно своих аргументов, CONS --- нет;
    \item CONS эффективнее LIST.
\end{itemize}

