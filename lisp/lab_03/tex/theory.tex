\chapter{Теоретические вопросы}

\section{Базис языка Lisp. Ядро языка.}

\textbf{Базис языка} --- минимальный набор инструментов и структур данных, который позволяет решать любые задачи.

\begin{lstlisting}
    Базис Lisp = атомы + структуры + 
                 базовые функции + базовые функционалы
\end{lstlisting}

\textbf{Функция} --- правило, по которому каждому значению одного или нескольких аргументов ставится в соответствие конкретное значение результата.

Примеры функций:
\begin{lstlisting}
    CAR         ; возвращает головную часть списка
    CDR         ; возвращает хвостовую часть списка
    CONS        ; включить новый элемент в начало списка
    ATOM        ; проверить, является ли аргумент атомом
    EQ          ; проверить тождественность двух символов
\end{lstlisting}

\textbf{Функционал (функция высшего порядка)} --- функция, аргументом или результатом которой является другая функция.

Примеры функционалов:
\begin{lstlisting}
    APPLY       ; применить функцию к списку аргументов
    FUNCALL     ; вызвать функцию с аргументами
\end{lstlisting} 

\textbf{Ядро} --- основные действия, которые наиболее часто используются. Такие функции системы обычно реализовываны в виде машинных подпрограмм.


\section{Классификация функций}

\begin{enumerate}
    \item \textbf{Чистые математические функции} --- имеют фиксированное количество аргументов, сначала вычисляются все аргументы, а потом к ним применяется функция.
    \item \textbf{Рекурсивные функции} --- основной способ повторения повторных вычислений.
    \item \textbf{Специальные функции (формы)} --- могут принимать произвольное количество элементов, элементы могут обрабатываться по разному.
    \item \textbf{Псевдофункции} --- создают "эффект", например, вывод на экран.
    \item \textbf{Функции с вариантами значений}, из которых выбирается одно.
    \item \textbf{Функции высших порядков (функционалы)} --- функции, аргументом или результатом которых является другая функция.
\end{enumerate}

\section{Классификация базисных функций и функций ядра}
\begin{enumerate}
    \item Селекторы 
    \begin{lstlisting}
    CAR         ; возвращает первый элемент списка
    CDR         ; возвращает хвостовую часть списка
    \end{lstlisting}

    \item Конструкторы
    \begin{lstlisting}
    CONS        ; включить новый элемент в начало списка
    LIST        ; составить список из своих аргументов
    \end{lstlisting}

    \item Предикаты --- логические функции, позволяющие определить структуру элемента.
    \begin{lstlisting}
    ATOM        ; проверить, является ли аргумент атомом
    NULL        ; проверить, является ли аргумент пустым списком
    LISTP       ; проверить, является ли аргумент списком
    CONSP       ; проверить, является ли аргумент структурой,   
                  представленной в виде списковой ячейки
    \end{lstlisting}

    \item Функции сравнения (перечислены по мере роста "тщательности" проверки)
    \begin{lstlisting}
    EQ          ; сравнивает два символьных атома (= указатели)
    EQL         ; сравнивает атомы и числа одинакового типа
    =           ; сравнивает только числа, могут быть разных типов
    EQUAL       ; EQL + сравнивает списки 
    EQUALP      ; сравнивает любые S-выражения
    \end{lstlisting}
    
\end{enumerate}

\section{Способы задания функций}

Определение функций пользователя в Лиспе возможно двумя способами.

\subsection{Базисный способ определения функции}

Предполагает использование $\lambda$-выражения ($\lambda$-нотации). Так создаются функции без имени. 

Способ задания функции: \textbf{$\lambda$-выражение: (lambda $\lambda$-список форма)}, где $\lambda$-список --- формальные параметры функции, форма --- тело функции. 

Вызов такой функции осуществляется следующим образом: \textbf{($\lambda$-выражение формы)}, где формы --- это фактические параметры. 

Вычисление функций без имени может быть также выполнено с помощью функционала \textbf{apply}: \textbf{(apply $\lambda$-выражение формы)}. 
Функционал apply является обычной функцией с двумя вычисляемыми аргументами, обращение к ней имеет вид 
\begin{lstlisting}
    apply F L           ;   F -- функциональный аргумент 
                        ;   L -- список фактических параметров
\end{lstlisting}

Значение функционала --- результат применения F к этим фактическим параметрам.

Вычисление функций без имени может быть также выполнено с помощью функционала \textbf{funcall}: \textbf{(funcall $\lambda$-выражение формы)}. Функционал funcall --- особая функция с вычисляемыми аргументами, обращение к ней
\begin{lstlisting}
    funcall  F e1 .. en         ; n >= 0
\end{lstlisting}

Действие аналогично apply, отличие в том, что аргументы передаются не в виде списка, а по отдельности.

\subsection{Использование макро-определения defun}

Задание функции: \textbf{(defun имя-функции $\lambda$-выражение)} или в облегченной форме \textbf{(defun имя-функции ($x_1$, $x_2$, .. $x_k$) форма)}.

Вызов именованной функции: \textbf{(имя-функции последовательность-форм)}. 

Для вызова можно также воспользоваться функционалами funcall и apply.

\begin{lstlisting}
    (foo 1 2 3)
    (funcall  #'foo 1 2 3)
    (apply #'foo (1 2 3))
\end{lstlisting}

\section{Работа функций COND, IF, AND/OR}

\subsection{COND}

Общий вид условного выражения:  

\textbf{(COND ($p_1$ $e_{11}$ .. $e_{1m_1}$) ($p_2$ $e_{21}$ .. $e_{2m_2}$) .. ($p_n$ $e_{nn}$ .. $e_{nm_n}$)), $m_i \geq 0$, $n \geq  1$}

Вычисление условного выражения выполняется по следующим правилам:

\begin{enumerate}
    \item последовательно вычисляются условия $p_1 .. p_n$ ветвей выражения до тех пор, пока не встретится выражение $p_i$, отличное от NIL;
    \item последовательно вычисляются выражения-формы $e_{i1} .. e_{im_i}$ соответствующей ветви, и значение последнего выражения $e_{im_i}$ возвращается в качестве значения функции cond;
    \item если все условия $p_i$ имеют значения NIL, то значением условного выражения становится NIL.
\end{enumerate}

Пример:
\begin{lstlisting}
     (
     cond 
        ((< X 5) (print "a") X)
        ((= X 9) (print "b") X)
        (T       (print "c") X)
     )

     ; Возвращает всегда X, при этом выведена будет одна из трех строк
\end{lstlisting}

\newpage

\subsection{IF}

Макрофункция (IF C E1 E2), вычисляет значение выражения E1, если значение выражения C отлично от NIL, в ином случае она вычисляет E2.

\begin{lstlisting}
     (if c e1 e2) == (list 'cond (list c e1) (list T e2))

     (if (< 3 5) (print "a") (print "b"))
        ===
     (list 'cond (list (< 3 5) (print "a")) (list T (print "b")))
\end{lstlisting}

\subsection{AND/OR}

Вызов функции and, реализующей конъюнкцию, имеет вид (AND $e_1$ .. $e_n$). 

При выполнении этого функционального обращения последовательно слева направо вычисляются аргументы $e_i$, до тех пор, пока не встретится значение, равное NIL. В этом случае выполнение функции прерывается, возвращается NIL. Если все $e_i$ отличны от NIL, то результатом будет $e_n$.

\text{\newline}

Вызов функции or, реализующей конъюнкцию, имеет вид (OR $e_1$ .. $e_n$). 

При выполнении этого функционального обращения последовательно слева направо вычисляются аргументы $e_i$, до тех пор, пока не встретится значение, отличное от NIL. В этом случае выполнение функции прерывается, возвращается $e_i$. Если все $e_i$ равны NIL, то результатом будет NIL.

\text{\newline}

Таким образом, значения функций and и or не обязательно равно T и NIL, а может быть произвольным атомом или списочным выражением. 
