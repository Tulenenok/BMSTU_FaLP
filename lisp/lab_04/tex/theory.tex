\chapter{Теоретические вопросы}

\section{Синтаксическая форма и хранение программы в памяти}

Программа на Lisp представляет собой вызов функции на верхнем уровне. Все операции над данными оформляются и  записываются как функции, которые имеют значение, даже если их основное предназначение --- осуществление некоторого побочного эффекта. Программа является ничем иным, как набором запрограммированных функций.

Синтаксически программа оформляется в виде S-выражения (обычно -- списка -- частного случая точечной пары), которое очень часто может быть структурированным. Наличие скобок является признаком структуры. 

Определения:
\begin{itemize}
	\item S-выражение ::= <атом> | <точечная пара>

	\item Атомы:
\begin{itemize} 
	\item символы (идентификаторы) --- синтаксически --- набор литер (букв и цифр), начинающихся с буквы;
	\item специальные символы --- {T, Nil} (используются для обозначения логических констант);
	\item самоопределимые атомы --- натуральные числа, дробные числа, вещественные числа, строки – последовательность символов, заключенных в двойные апострофы (например, "abc");
\end{itemize} 


\item Точечная пара:
\begin{lstlisting}
    Точечная пара ::= (<атом> . <атом>) | 
                      (<атом> . <точечная пара>) | 
                      (<точечная пара> . <атом>) | 
                      (<точечная пара> . <точечная пара>) 
\end{lstlisting}

\item Список:
\begin{lstlisting}
    Список ::= <пустой список> | <непустой список>, где
                
    <пусой сисок> ::= ( ) | Nil,
    <непустой список>::= (<первый элемент> . <хвост>),
    <первый элемент> ::= <S-выражение>,
    <хвост> ::= <список>
\end{lstlisting}


\end{itemize}

Атомы представляются в памяти пятью указателями  (name, value, function, property, package), а любая непустая структура ---  списковой ячейкой (бинарным узлом), хранящей два указателя: на голову (первый элемент) и хвост --- все остальное.

\section{Трактовка элементов списка}

По определению списка, приведенному выше: если список непустой, то он представляет из себя точечную пару из  <первого элемента> и <хвоста>, где <первый элемент> --- это <S-выражение>, а <хвост> --- это <список>.

Список можно вычислить, если он представляет собой обращение к  функции, или функциональный вызов: (f e1 e2 … en), где f --- символьный атом, имя вызываемой функции; e1, e2, …, en --- аргументы этой функции; n - число аргументов функции.

В случае n = 0 имеем вызов функции без аргументов: (f). Обычно e1, e2, …, en являются вычислимыми выражениями и вычисляются последовательно слева направо.

Таким образом, если в процессе работы лисп-интерпретатора  требуется вычислить некоторый список, то первым элементом этого   списка должно быть имя функции. Если это не так, лисп-интерпретатор  сообщает об ошибке и прерывает вычисление текущего выражения  программы.

\section{Порядок реализации программы}

Обычно лисп-программа включает определения новых функций на базе встроенных функций и других функций, определённых в этой программе, а также вызовы этих новых функций для конкретных значений их аргументов.

Программа на Lisp представляет собой вызов функции на верхнем уровне и синтаксически оформляется в виде S-выражения. Вычисление программы реализует лисп-интерпретатор, который считывает очередную входящую в программу форму, вычисляет её (анализирует функцией eval) и выводит полученный результат (S-выражение).

Eval выполняет двойное  вычисление своего аргумента. Эта функция является обычной, и первое  вычисление аргумента выполняет так же, как и любая обычная функция.  Полученное при этом выражение вычисляется ещё раз. Такое двойное  вычисление может понадобиться либо для снятия блокировки вычислений (установленной функцией quote), либо же для вычисления сформированного в ходе первого вычисления нового функционального вызова.


\section{Способы задания функций}

\textbf{Функция} --- правило, по которому каждому значению одного или нескольких аргументов ставится в соответствие конкретное значение результата.

\textbf{Функционал (функция высшего порядка)} --- функция, аргументом или результатом которой является другая функция.

Определение функций пользователя в Лиспе возможно двумя способами.

\subsection{Базисный способ определения функции}

Предполагает использование $\lambda$-выражения. Так создаются функции без имени. 

Способ задания функции: \textbf{$\lambda$-выражение: (lambda $\lambda$-список форма)}, где $\lambda$-список --- формальные параметры функции, форма --- тело функции. 

Вызов такой функции осуществляется следующим образом: \textbf{($\lambda$-выражение формы)}, где формы --- это фактические параметры. 

Вычисление функций без имени может быть также выполнено с помощью функционала \textbf{apply}: \textbf{(apply $\lambda$-выражение формы)}. 
Функционал apply является обычной функцией с двумя вычисляемыми аргументами, обращение к ней имеет вид 
\begin{lstlisting}
    apply F L           ;   F -- функциональный аргумент 
                        ;   L -- список фактических параметров
\end{lstlisting}

Значение функционала --- результат применения F к этим фактическим параметрам.

Вычисление функций без имени может быть также выполнено с помощью функционала \textbf{funcall}: \textbf{(funcall $\lambda$-выражение формы)}. Функционал funcall --- особая функция с вычисляемыми аргументами, обращение к ней
\begin{lstlisting}
    funcall  F e1 .. en         ; n >= 0
\end{lstlisting}

Действие аналогично apply, отличие в том, что аргументы передаются не в виде списка, а по отдельности.

\subsection{Использование макро-определения defun}

Задание функции: \textbf{(defun имя-функции $\lambda$-выражение)} или в облегченной форме \textbf{(defun имя-функции ($x_1$, $x_2$, .. $x_k$) форма)}.

Вызов именованной функции: \textbf{(имя-функции последовательность-форм)}. 

Для вызова можно также воспользоваться функционалами funcall и apply.

\begin{lstlisting}
    (foo 1 2 3)
    (funcall  #'foo 1 2 3)
    (apply #'foo (1 2 3))
\end{lstlisting}

\section{Работа функций COND, IF, AND/OR}

\subsection{COND}

Общий вид условного выражения:  

\textbf{(COND ($p_1$ $e_{11}$ .. $e_{1m_1}$) ($p_2$ $e_{21}$ .. $e_{2m_2}$) .. ($p_n$ $e_{nn}$ .. $e_{nm_n}$)), $m_i \geq 0$, $n \geq  1$}

Вычисление условного выражения выполняется по следующим правилам:

\begin{enumerate}
    \item последовательно вычисляются условия $p_1 .. p_n$ ветвей выражения до тех пор, пока не встретится выражение $p_i$, отличное от NIL;
    \item последовательно вычисляются выражения-формы $e_{i1} .. e_{im_i}$ соответствующей ветви, и значение последнего выражения $e_{im_i}$ возвращается в качестве значения функции cond;
    \item если все условия $p_i$ имеют значения NIL, то значением условного выражения становится NIL.
\end{enumerate}

Пример:
\begin{lstlisting}
     (
     cond 
        ((< X 5) (print "a") X)
        ((= X 9) (print "b") X)
        (T       (print "c") X)
     )

     ; Возвращает всегда X, при этом выведена будет одна из трех строк
\end{lstlisting}

\subsection{IF}

Макрофункция (IF C E1 E2), вычисляет значение выражения E1, если значение выражения C отлично от NIL, в ином случае она вычисляет E2.

\begin{lstlisting}
     (if c e1 e2) == (list 'cond (list c e1) (list T e2))

     (if (< 3 5) (print "a") (print "b"))
        ===
     (list 'cond (list (< 3 5) (print "a")) (list T (print "b")))
\end{lstlisting}

\subsection{AND/OR}

Вызов функции and, реализующей конъюнкцию, имеет вид (AND $e_1$ .. $e_n$). 

При выполнении этого функционального обращения последовательно слева направо вычисляются аргументы $e_i$, до тех пор, пока не встретится значение, равное NIL. В этом случае выполнение функции прерывается, возвращается NIL. Если все $e_i$ отличны от NIL, то результатом будет $e_n$.

\text{\newline}

Вызов функции or, реализующей конъюнкцию, имеет вид (OR $e_1$ .. $e_n$). 

При выполнении этого функционального обращения последовательно слева направо вычисляются аргументы $e_i$, до тех пор, пока не встретится значение, отличное от NIL. В этом случае выполнение функции прерывается, возвращается $e_i$. Если все $e_i$ равны NIL, то результатом будет NIL.

\text{\newline}

Таким образом, значения функций and и or не обязательно равно T и NIL, а может быть произвольным атомом или списочным выражением. 

\subsection{APPEND}

Функция append объединяет два списка. 

Идея работы функции состоит в том, что рекурсивно откладываются вызовы функции CONS с элементами списка X до тех пор, пока он не исчерпается, после чего в качестве результата возвращается указатель на список Y и отложенные вызовы, завершая свою работу, формируют результат.

\begin{lstlisting}
     (
        defun
        my_append
        (x y)
        (
        cond ((null x) y)
             (t (cons (car x)
                      (my_append (cdr x) y)
                )
             )
        )
    )

    (my_append '(1 2) '(3 4))       ; (1 2 3 4)
    (append '(1 2) '(3 4))          ; (1 2 3 4)
\end{lstlisting}

\subsection{REVERSE}

Функция reverse изменяет порядок элементов в списке (на верхнем уровне) на обратный. Идея определения функции состоит в следующем: берем первый элемент списка, делаем из него одноэлементный список и объединяем его функцией append с перевернутым хвостом. Хвост списка сначала обращается рекурсивным вызовом.

\begin{lstlisting}
     (
         defun
         my_reverse
         (l)
         (
         cond ((null l) nil)
              (t (append (my_reverse (cdr l))
                         (cons (car l) nil)
                 )
              )
         )
     )

      (defvar a '(1 2 3))
     (my_reverse a)         ; (3 2 1)
     (reverse a)            ; (3 2 1)
\end{lstlisting}


\subsection{LAST}

С помощью этой функции можно выделить последний элемент списка.

Как такую функцию можно определить:
\begin{lstlisting}
     (
        defun
        my_last
        (l)
        (cond ((null l) nil)
              ((null (cdr l)) (car l))
              (t (my_last (cdr l)))
        )
     )

     (defvar a '(1 2 3))
     (my_last a)                    ; (3)
     (last a)                       ; (3)
\end{lstlisting}



